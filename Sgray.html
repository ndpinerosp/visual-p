<!DOCTYPE HTML>
<!--
	TXT by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Shader GrayScale</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">
		<div id="page-wrapper">

			<!-- Header -->
			<header id="header">
				<div class="logo container">
					<div>
						<h1><a href="index.html" id="logo">Visual-p</a></h1>
						
					</div>
				</div>
			</header>

			<!-- Nav -->
			<nav id="nav">
				<ul>
					<li><a href="index.html">Home</a></li>
					<li><a href="pixels.html">Pixels</a></li>
					<li><a>Software Processing</a>
						<ul>
							<li>
							<a>GrayScale</a>
								<ul>
								<li><a href="Igray.html">Image GrayScale</a></li>
								<li><a href="Vgray.html">Video GrayScale</a></li>
								</ul>
							</li>
							<li>
								<a>Convolution Matrix</a>
								<ul>
									<li><a href="Imask.html">Image Convolution Matrix</a></li>
									<li><a href="Vmask.html">Video Convolution Matrix</a></li>
								</ul>
							</li>
							<li><a href="segmentacion.html">Image Segmentation</a></li>
						</ul>
					</li>
					<li class="current"><a>Hardware Processing</a>
						<ul>
							<li><a href="Sgray.html">GrayScale</a></li>
							<li><a href="Smask.html">Convolution Matrix</a></li>
						</ul>
					</li>
					<li><a>illusion</a>
                        <ul>
                            <li><a>Geometrical</a>
                            <ul>
                                <li> <a href="hering.html">Hering illusion</a></li>
                                <li> <a href="poggendorff.html">poggendorff illusion</a></li>
                            </ul>
                            </li>
							<li><a>Movement</a>
								<ul>
									<li> <a href="stepping_feet.html">Stepping feet</a></li>
									<li> <a href="strobo.html">Stroboscopic Effect</a></li>
								</ul>
							</li>
							<li><a>Other</a>
								<ul>
									<li> <a href="munker_white.html">Munker White</a></li>
									<li> <a href="moire_pattern.html">Moire Pattern</a></li>
									<li> <a href="penrose.html">Penrose Triangle</a></li>
								</ul>
							</li>
							<li><a>3D</a>
								<ul>
									<li> <a href="3d.html">Missing Corner Cube</a></li>
									<li> <a href=""> </a></li>
								</ul>
							</li>
                        </ul>
					</li>
					<li><a>Light</a>
                        <ul>
							<li> <a href="light_amb.html">Ambient Light</a></li>
							<li> <a href="fog.html">Fog </a></li>
                            <li> <a href="light_comb.html">Combination light </a></li>
                        </ul>
                    </li>
					<li ><a href="#about" class="button scrolly">About</a></li>
				</ul>
			</nav>

			<!-- Main -->
				<section id="main">
					<div class="container">
						<div class="row">
							<div class="col-12">
								<div class="content">

									<!-- Content -->

										<article class="box page-content">

											<header>
												<h2>GrayScale Image and Video</h2>
												<p>Shaders and Webgl</p>
												<ul class="meta">
													<li class="icon fa-clock">02 Oct</li>
												</ul>
											</header>
											<section>
												<p>
												En esta publicación se desea mostrar los resultados obtenidos al realizar el procesamiento de imágenes y videos con shaders utilizando un leguaje de alto nivel, como lo es GLSL, para empezar a aprovechar las características de nuestro hardware y tener resultados muy favorables a nivel de máquina. El cambio y rendimiento, comparado con la velocidad de respuesta es notable en comparación con el procesamiento de imágenes y videos por medio de hardware.
												<br><br>
												A continuación, se observará cómo se puede obtener una imagen y video a escala de grises a partir del Promedio de los componentes RGB de una imagen y el caculo del coeficiente Luma. Para ello esta basada en la pagina de wikipedia <a href="https://en.wikipedia.org/wiki/HSL_and_HSV#Lightness">HSL and HSV</a>, el tutorial de shaders del profesor <strong>Andres Colubri</strong>  en el sitio web <a href="https://processing.org/tutorials/pshader/">processing.org</a> y el tutorial de la página <a href="https://itp-xstory.github.io/p5js-shaders/#/">itp-xstory.github.io </a>
												donde se explican conceptos básicos de shaders con p5.js. En gran medida la construcción de este programa está basado en el anteriror ejemplo <a href="Igray.html">Image GrayScale</a> del procesamiento de imágenes con software, ya que se manejan funciones y procedimientos muy similares, 
												sin embargo, para el procesamiento por hardware,lo que se hacia para uno solo pixel en software, ahora se hace en paralelo para todos los pixeles.
												</p>
											<hr>
												<h4>Comandos por Teclado</h4>
												<div class="table-wrapper text-center" >
													<table>
														<thead>
															<th>Tecla</th>
															<th>Operacion</th>
															<th>Expresion</th>
														</thead>
														<tbody>
															<tr>
																<td><img src="images/0.png" style="width:40px;vertical-align: middle" ></td>
																<td>Original</td>
																<td>(R,G,B)</td>
															</tr>
															<tr>
																<td><img src="images/1.png" style="width:40px;vertical-align: middle" ></td>
																<td>Media Aritmetica</td>
																<td>I = Avg(R,G,B)</td>
															</tr>
															<tr>
																<td><img src="images/2.png" style="width:40px;vertical-align: middle" ></td>
																<td>Componente mas grande</td>
																<td> M = Max(R,G,B)</td>
															</tr>
															<tr>
																<td><img src="images/3.png" style="width:40px;vertical-align: middle" ></td>
																<td>Rango Medio</td>
																<td> L = (max(R,G,B)+min(R,G,B))/2 </td>
															</tr>
															<tr>
																<td><img src="images/4.png" style="width:40px;vertical-align: middle" ></td>
																<td>Luma Y601</td>
																<td> Y601 = 0.2989*R + 0.5870*G + 0.1140*B </td>
															</tr>
															<tr>
																<td><img src="images/5.png" style="width:40px;vertical-align: middle" ></td>
																<td>Luma Y240</td>
																<td> Y240 = 0.212*R + 0.701*G + 0.087*B </td>
															</tr>
															<tr>
																<td><img src="images/6.png" style="width:40px;vertical-align: middle" ></td>
																<td>Luma 709</td>
																<td> Y709 = 0.2126*R + 0.7152*G + 0.0722*B </td>
															</tr>
													
														</tbody>
													</table>

												</div>

											</section>

											<section>
												
												<div style="width:800px; margin:0 auto;">
													<iframe src="p5/hardware/gray_shader/index.html" style="position:center;height:500px;width:900px"></iframe>
												</div>
										
										<p>
												<p>
													Para esta implementacion se hizo el uso de <a href="https://visualcomputing.github.io/FragmentShaders/#/1">Shaders</a>, el cual se configura mediante un
													archivo .frag , el cual se encarga de hacer las operaciones para poder calcular la escala de grises de los pixeles de la imagen de manera paralela, a este archivo 
													solo se le envia la imagen o video y el tipo de escala de grises a realizar. Adicionalmente a esto la imagen se agrego com una textura al circulo mostrado en el ejemplo anterior.
													<br><br>
													En comparacion con ejemplos anteriores para este podemos observar que se tiene una mejor eficiencia al poder operar los pixeles de forma paralela
													mediante el uso de la tarjeta grafica, ya que como se habia observado anteriormente en el ejemplo <a href="Vgray.html">Video GrayScale</a>, notamos que la eficiencia del
													video era de aproximadamente <strong> 15 F/S</strong> en promedio, al aplicar las diferentes formas de escalas de grises, en cambio para este ejemplo el conserva los fotogramas 
													del video en aproximadamente <strong> 58 F/S</strong>, conservando la fluidez del video , aunque se esten aplicando las diversas escalas de grises, lo cual comparandolo mediante la implementacion por software
													muestra una mejoria en la utilizacion de recursos y una mayor rapidez en el procesamiento .
												</p>
											</section>

										</article>

								</div>
							</div>
							<div class="col-12">

								<!-- Features -->
									<section class="box features">
										<h2 class="major"><span>Otros Ejemplos</span></h2>
										<div>
											<div class="row" >
												<div class="col-3 col-6-medium col-12-small centro">

													<!-- Feature -->
														<section class="box feature">
															<a href="Vgray.html" class="image featured"><img src="images/pic01.jpg" alt="" /></a>
															<h3><a href="Vgray.html">Video GrayScale</a></h3>
															<p>
																Rgb Average and luma coefficient, Frame rate
															</p>
														</section>

												</div>
												<div class="col-3 col-6-medium col-12-small centro">

													<!-- Feature -->
														<section class="box feature">
															<a href="Smask.html" class="image featured"><img src="images/pic02.jpg" alt="" /></a>
															<h3><a href="Smask.html">Shader Convolution Matrix</a></h3>
															<p>
																Shaders and WEBGL
															</p>
														</section>

												</div>
												
												
												
											</div>
										</div>
									</section>

							</div>
						</div>
					</div>
				</section>

			<!-- Footer -->
			<div id="footer">
			</div>

		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script> 
				$(function(){
					 $("#footer").load("footer.html"); 
				});
				</script> 

	</body>
</html>